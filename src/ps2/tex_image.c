
/* ================================================================================================
 * -*- C -*-
 * File: tex_image.c
 * Author: Guilherme R. Lampert
 * Created on: 18/10/15
 * Brief: Texture management and image loading for the PS2.
 *
 * This source code is released under the GNU GPL v2 license.
 * Check the accompanying LICENSE file for details.
 * ================================================================================================ */

#include "ps2/ref_ps2.h"
#include "ps2/mem_alloc.h"
#include "common/q_files.h"

//
// Built-in images found in src/ps2/builtin/
//
// These are common UI textures like the console
// chars and overlays that I've dumped as raw
// arrays of bytes from the originals found in
// pak0.pak. The ones with no transparency are
// stored as uint16s to save space, conchars.pcx
// is saved as an array of RGBA bytes.
//
// I've embedded these mostly to facilitate testing,
// since it makes the executable stand-alone and we
// can still draw the console nicely. There's an imgdump.c
// file that is the tool used to read the PCX images
// and dump the pixels as arrays of bytes.
//
// global_palette is also generated by it from colormap.pcx.
//

// conchars.pcx RGBA-32:
extern const int conchars_width;
extern const int conchars_height;
extern const byte conchars_data[];

// conback.pcx RGB-16:
extern const int conback_width;
extern const int conback_height;
extern const byte conback_data[];

// inventory.pcx RGB-16:
extern const int inventory_width;
extern const int inventory_height;
extern const byte inventory_data[];

// help.pcx RGB-16:
extern const int help_width;
extern const int help_height;
extern const byte help_data[];

// backtile.pcx RGB-16:
extern const int backtile_width;
extern const int backtile_height;
extern const byte backtile_data[];

// These are always available in main RAM, since the
// texture data comes directly from the above arrays.
ps2_teximage_t * builtin_tex_conchars  = NULL;
ps2_teximage_t * builtin_tex_conback   = NULL;
ps2_teximage_t * builtin_tex_inventory = NULL;
ps2_teximage_t * builtin_tex_help      = NULL;
ps2_teximage_t * builtin_tex_backtile  = NULL;
ps2_teximage_t * builtin_tex_debug     = NULL;

//=============================================================================
//
// Texture image allocations and management:
//
//=============================================================================

// Pack an RGBA into a 16bits word. 1 bit alpha, A-B-G-R internal order.
#define RGBA16(r, g, b, a) \
    ((((a) & 0x1) << 15) | (((b) >> 3) << 10) | (((g) >> 3) << 5) | ((r) >> 3))

/*
==============
CheckerPattern
==============
*/
enum
{
    CHECKER_DIM     = 64,
    CHECKER_SQUARES = 4,
    CHECKER_SIZE    = CHECKER_DIM / CHECKER_SQUARES
};
static u16 * CheckerPattern(void) // RGBA 16bits
{
    const u16 colors[] =
    {
        RGBA16(255, 100, 255, 255), // pink
        RGBA16(0, 0, 0, 255)        // black
    };
    static u16 buffer[CHECKER_DIM * CHECKER_DIM] __attribute__((aligned(16)));

    int x, y, colorindex;
    for (y = 0; y < CHECKER_DIM; ++y)
    {
        for (x = 0; x < CHECKER_DIM; ++x)
        {
            colorindex = ((y / CHECKER_SIZE) + (x / CHECKER_SIZE)) % 2;
            buffer[x + (y * CHECKER_DIM)] = colors[colorindex];
        }
    }

    return buffer;
}

/*
==============
PS2_TexImageInit
==============
*/
void PS2_TexImageInit(void)
{
    if (ps2ref.num_teximages != 0)
    {
        Sys_Error("Invalid PS2_TexImageInit call!");
    }

    //
    // Create the built-in textures:
    //

    builtin_tex_debug = PS2_TexImageAlloc();
    PS2_TexImageSetup(builtin_tex_debug, "pics/debug.pcx", CHECKER_DIM, CHECKER_DIM,
                      TEXTURE_COMPONENTS_RGB, TEXTURE_FUNCTION_MODULATE, GS_PSM_16,
                      LOD_MAG_NEAREST, LOD_MIN_NEAREST, IT_BUILTIN, (byte *)CheckerPattern());

    builtin_tex_backtile = PS2_TexImageAlloc();
    PS2_TexImageSetup(builtin_tex_backtile, "pics/backtile.pcx", backtile_width,backtile_height,
                      TEXTURE_COMPONENTS_RGB, TEXTURE_FUNCTION_MODULATE, GS_PSM_16,
                      LOD_MAG_NEAREST, LOD_MIN_NEAREST, IT_BUILTIN, (byte *)backtile_data);

    builtin_tex_inventory = PS2_TexImageAlloc();
    PS2_TexImageSetup(builtin_tex_inventory, "pics/inventory.pcx", inventory_width, inventory_height,
                      TEXTURE_COMPONENTS_RGB, TEXTURE_FUNCTION_MODULATE, GS_PSM_16,
                      LOD_MAG_NEAREST, LOD_MIN_NEAREST, IT_BUILTIN, (byte *)inventory_data);

    builtin_tex_help = PS2_TexImageAlloc();
    PS2_TexImageSetup(builtin_tex_help, "pics/help.pcx", help_width, help_height,
                      TEXTURE_COMPONENTS_RGB, TEXTURE_FUNCTION_MODULATE, GS_PSM_16,
                      LOD_MAG_NEAREST, LOD_MIN_NEAREST, IT_BUILTIN, (byte *)help_data);

    builtin_tex_conback = PS2_TexImageAlloc();
    PS2_TexImageSetup(builtin_tex_conback, "pics/conback.pcx", conback_width, conback_height,
                      TEXTURE_COMPONENTS_RGB, TEXTURE_FUNCTION_MODULATE, GS_PSM_16,
                      LOD_MAG_NEAREST, LOD_MIN_NEAREST, IT_BUILTIN, (byte *)conback_data);

    builtin_tex_conchars = PS2_TexImageAlloc();
    PS2_TexImageSetup(builtin_tex_conchars, "pics/conchars.pcx", conchars_width, conchars_height,
                      TEXTURE_COMPONENTS_RGBA, TEXTURE_FUNCTION_MODULATE, GS_PSM_32,
                      LOD_MAG_NEAREST, LOD_MIN_NEAREST, IT_BUILTIN, (byte *)conchars_data);
}

/*
==============
PS2_TexImageShutdown
==============
*/
void PS2_TexImageShutdown(void)
{
    //TODO cleanup all allocated textures on ps2ref.teximages!!
    //remember we can't free the debug tex since it is generated!!!
    //teximages with type IT_BUILTIN can't be freed
}

/*
==============
PS2_TexImageAlloc
==============
*/
ps2_teximage_t * PS2_TexImageAlloc(void)
{
    if (ps2ref.num_teximages == MAX_TEXIMAGES)
    {
        Sys_Error("Out of tex images!!!");
    }

    //TODO assume always sequential, or allow empty gaps???
    return &ps2ref.teximages[ps2ref.num_teximages++];
}

/*
==============
Img_NameHash
OAT - One-At-a-Time hash of the filename of an image.
https://en.wikipedia.org/wiki/Jenkins_hash_function
==============
*/
static inline u32 Img_NameHash(const char * name)
{
    u32 hash = 0;

    while (*name != '\0')
    {
        hash += *name++;
        hash += (hash << 10);
        hash ^= (hash >> 6);
    }

    hash += (hash << 3);
    hash ^= (hash >> 11);
    hash += (hash << 15);

    return hash;
}

/*
==============
Img_FindImpl
==============
*/
static ps2_teximage_t * Img_FindImpl(const char * name, int flags)
{
    if (name == NULL)
    {
        Com_DPrintf("FindImage: Null name!");
        return NULL;
    }

    const u32 name_len = strlen(name);
    if (name_len < 5)
    {
        Com_DPrintf("FindImage: Bad name, too short: %s", name);
        return NULL;
    }

    // Compare by hash code, much cheaper.
    const u32 name_hash = Img_NameHash(name);

    // First, lookup our cache:
    u32 i;
    const u32 num_teximages    = ps2ref.num_teximages;
    ps2_teximage_t * teximages = ps2ref.teximages;

    for (i = 0; i < num_teximages; ++i)
    {
        if ((name_hash == teximages[i].hash) && (flags & teximages[i].type))
        {
            return &teximages[i];
        }
    }

    //TODO load form file
    return NULL;
}

/*
==============
PS2_TexImageFindOrLoad
==============
*/
ps2_teximage_t * PS2_TexImageFindOrLoad(const char * name, int flags)
{
    ps2_teximage_t * teximage;
    char fullname[MAX_QPATH];

    // This is the same logic used by ref_gl.
    // If the name doesn't start with a path separator, its just the base
    // filename, like "conchars", otherwise the full file path is specified in 'name'.
    if (name[0] != '/' && name[0] != '\\')
    {
        Com_sprintf(fullname, sizeof(fullname), "pics/%s.pcx", name);
        teximage = Img_FindImpl(fullname, flags);
    }
    else
    {
        teximage = Img_FindImpl(name + 1, flags);
    }

    return teximage;
}

/*
==============
PS2_TexImageSetup
==============
*/
void PS2_TexImageSetup(ps2_teximage_t * teximage, const char * name, int w, int h, int components,
                       int func, int psm, int mag_filter, int min_filter, ps2_imagetype_t type, byte * pic)
{
    if (w <= 0 || w > MAX_TEXIMAGE_SIZE)
    {
        Sys_Error("Bad texture width (%d) for %s!", w, name);
    }
    if (h <= 0 || h > MAX_TEXIMAGE_SIZE)
    {
        Sys_Error("Bad texture height (%d) for %s!", h, name);
    }

    // All textures must share the same VRam space.
    // What this means is that we only have enough VRam
    // left for a single texture at a time, so every texture
    // must be copied to VRam on-the-fly, prior to any use.
    teximage->texbuf.address = ps2ref.vram_texture_start;

    teximage->pic                    = pic;
    teximage->width                  = w;
    teximage->height                 = h;
    teximage->mag_filter             = mag_filter;
    teximage->min_filter             = min_filter;
    teximage->type                   = type;
    teximage->texbuf.psm             = psm;
    teximage->texbuf.width           = w;
    teximage->texbuf.info.width      = draw_log2(w);
    teximage->texbuf.info.height     = draw_log2(h);
    teximage->texbuf.info.components = components;
    teximage->texbuf.info.function   = func;

    // These are only used by the scrap atlas.
    teximage->u0 = teximage->u1 = 0;
    teximage->v0 = teximage->v1 = 0;

    // Finally, copy and hash the name string:
    strncpy(teximage->name, name, MAX_QPATH);
    teximage->hash = Img_NameHash(name);
}

/*
==============
PS2_TexImageFree
==============
*/
void PS2_TexImageFree(ps2_teximage_t * teximage)
{
    // Built-ins will always be referencing static program data.
    if (teximage->pic != NULL && teximage->type != IT_BUILTIN)
    {
        PS2_MemFree(teximage->pic, MEMTAG_TEXIMAGE);
    }

    PS2_MemClearObj(teximage);
}

//=============================================================================
//
// Scrap allocation - AKA texture atlas
// Useful to group small textures into a larger one,
// reducing the number of texture switches when rendering.
//
//=============================================================================

static int scrap_allocated[MAX_TEXIMAGE_SIZE] __attribute__((aligned(16)));
static u32 scrap_pixels[MAX_TEXIMAGE_SIZE * MAX_TEXIMAGE_SIZE] __attribute__((aligned(16)));

/*
==============
Scrap_AllocBlock
==============
*/
ps2_teximage_t * Scrap_AllocBlock(const byte * pic8in, int w, int h, const char * pic_name)
{
    int i, j, k;
    int sx, sy;
    int best, best2;
    ps2_teximage_t * scrap_teximage;
    u32 temp_pic32[MAX_TEXIMAGE_SIZE * MAX_TEXIMAGE_SIZE] __attribute__((aligned(16)));

    sx = sy = 0;
    best = MAX_TEXIMAGE_SIZE;

    // Try to find a good fit in the atlas:
    for (i = 0; i < MAX_TEXIMAGE_SIZE - w; ++i)
    {
        best2 = 0;
        for (j = 0; j < w; ++j)
        {
            if (scrap_allocated[i + j] >= best)
            {
                break;
            }
            if (scrap_allocated[i + j] > best2)
            {
                best2 = scrap_allocated[i + j];
            }
        }

        if (j == w) // This is a valid spot
        {
            sx = i;
            sy = best = best2;
        }
    }

    // No more room.
    if ((best + h) > MAX_TEXIMAGE_SIZE)
    {
        return NULL;
    }

    // Managed to allocate, update the scrap:
    for (i = 0; i < w; ++i)
    {
        scrap_allocated[sx + i] = best + h;
    }

    // Expand the pic to RGBA:
    Img_UnPalettize32(w, h, pic8in, global_palette, (byte *)temp_pic32);

    // Copy the texels into the scrap block:
    k = 0;
    for (i = 0; i < h; ++i)
    {
        for (j = 0; j < w; ++j, ++k)
        {
            scrap_pixels[(sy + i) * MAX_TEXIMAGE_SIZE + sx + j] = temp_pic32[k];
        }
    }

    scrap_teximage = PS2_TexImageAlloc();
    PS2_TexImageSetup(scrap_teximage, pic_name, w, h, TEXTURE_COMPONENTS_RGBA,
                      TEXTURE_FUNCTION_MODULATE, GS_PSM_32, LOD_MAG_NEAREST,
                      LOD_MIN_NEAREST, IT_BUILTIN, (byte *)scrap_pixels);

    scrap_teximage->u0 = sx;
    scrap_teximage->v0 = sy;
    scrap_teximage->u1 = sx + w;
    scrap_teximage->v1 = sy + h;

    perfcnt.scrap_allocs++;
    return scrap_teximage;
}

//=============================================================================
//
// PCX image loading helpers:
//
//=============================================================================

/*
==============
PCX_LoadFromMemory
'pic' and 'palette' can be null if you want to ignore one or the other.
If 'palette' is not null, it must point to an array of 256 32bit integers.
Mostly adapted from ref_gl/gl_image.c
==============
*/
qboolean PCX_LoadFromMemory(const char * filename, const byte * data, int data_len,
                            byte ** pic, u32 * palette, int * width, int * height)
{
    enum
    {
        PCX_PAL_SIZE_BYTES = 768
    };

    byte * pix;
    int x, y;
    int data_byte;
    int run_length;

    // Endian swap the header fields larger than a byte:
    const pcx_t * pcx  = (const pcx_t *)data;
    int manufacturer   = pcx->manufacturer;
    int version        = pcx->version;
    int encoding       = pcx->encoding;
    int bits_per_pixel = pcx->bits_per_pixel;
    int xmax           = LittleShort(pcx->xmax);
    int ymax           = LittleShort(pcx->ymax);

    // Validate the image:
    if (manufacturer != 0x0A || version != 5 || encoding != 1 ||
        bits_per_pixel != 8  || xmax >= 640  || ymax >= 480)
    {
        Sys_Error("Bad PCX file %s. Invalid header value(s)!", filename);
        return false;
    }

    // Get the palette:
    if (palette != NULL)
    {
        byte temp_pal[PCX_PAL_SIZE_BYTES] __attribute__((aligned(16)));
        memcpy(temp_pal, (const byte *)pcx + data_len - PCX_PAL_SIZE_BYTES, PCX_PAL_SIZE_BYTES);

        // Adjust the palette and fix byte order if needed:
        u32 c;
        int i, r, g, b;
        for (i = 0; i < 256; ++i)
        {
            r = temp_pal[(i * 3) + 0];
            g = temp_pal[(i * 3) + 1];
            b = temp_pal[(i * 3) + 2];
            c = (255 << 24) + (r << 0) + (g << 8) + (b << 16);
            palette[i] = LittleLong(c);
        }
        palette[255] &= LittleLong(0xFFFFFF); // 255 is transparent
    }

    if (width != NULL)
    {
        *width = xmax + 1;
    }
    if (height != NULL)
    {
        *height = ymax + 1;
    }

    if (pic == NULL)
    {
        // Caller just wanted the palette.
        return true;
    }

    // Now alloc and read in the pixel data:
    pix = PS2_MemAlloc((xmax + 1) * (ymax + 1), MEMTAG_TEXIMAGE);
    *pic = pix;

    // Skip the header:
    data = &pcx->data;

    // Decode the RLE packets:
    for (y = 0; y <= ymax; y++, pix += xmax + 1)
    {
        for (x = 0; x <= xmax;)
        {
            data_byte = *data++;
            if ((data_byte & 0xC0) == 0xC0)
            {
                run_length = data_byte & 0x3F;
                data_byte  = *data++;
            }
            else
            {
                run_length = 1;
            }

            while (run_length-- > 0)
            {
                pix[x++] = data_byte;
            }
        }
    }

    if ((data - (const byte *)pcx) > data_len)
    {
        Sys_Error("PCX image %s was malformed!", filename);
        PS2_MemFree(*pic, MEMTAG_TEXIMAGE);
        *pic = NULL;
        return false;
    }

    return true;
}

/*
==============
PCX_LoadFromFile
Mostly adapted from ref_gl/gl_image.c
==============
*/
qboolean PCX_LoadFromFile(const char * filename, byte ** pic,
                          u32 * palette, int * width, int * height)
{
    qboolean result;
    int data_len;
    byte * data;

    data_len = FS_LoadFile(filename, (void **)&data);
    if (data == NULL || data_len <= 0)
    {
        Sys_Error("Bad PCX file %s", filename);
        return false;
    }

    result = PCX_LoadFromMemory(filename, data, data_len, pic, palette, width, height);
    FS_FreeFile(data);

    return result;
}

//=============================================================================
//
// Palettized image expansion:
//
//=============================================================================

/*
==============
Img_UnPalettize32
Base algorithm adapted from GL_Upload8 in ref_gl/gl_image.c
==============
*/
void Img_UnPalettize32(int width, int height, const byte * restrict pic8in,
                       const u32 * restrict palette, byte * restrict pic32out)
{
    int i, p;
    const int pixel_count = width * height;
    u32 * restrict rgba = (u32 *)pic32out;

    for (i = 0; i < pixel_count; ++i)
    {
        p = pic8in[i];
        rgba[i] = palette[p];

        if (p == 255)
        {
            // Transparent, so scan around for another
            // color to avoid alpha fringes
            if (i > width && pic8in[i - width] != 255)
            {
                p = pic8in[i - width];
            }
            else if (i < pixel_count - width && pic8in[i + width] != 255)
            {
                p = pic8in[i + width];
            }
            else if (i > 0 && pic8in[i - 1] != 255)
            {
                p = pic8in[i - 1];
            }
            else if (i < pixel_count - 1 && pic8in[i + 1] != 255)
            {
                p = pic8in[i + 1];
            }
            else
            {
                p = 0;
            }

            // Copy RGB components:
            ((byte *)&rgba[i])[0] = ((const byte *)&palette[p])[0];
            ((byte *)&rgba[i])[1] = ((const byte *)&palette[p])[1];
            ((byte *)&rgba[i])[2] = ((const byte *)&palette[p])[2];
        }
    }
}

/*
==============
Img_UnPalettize24
==============
*/
void Img_UnPalettize24(int width, int height, const byte * restrict pic8in,
                       const u32 * restrict palette, byte * restrict pic24out)
{
    int i;
    u32 color;
    const int pixel_count = width * height;

    for (i = 0; i < pixel_count; ++i)
    {
        color = palette[pic8in[i]];
        *pic24out++ = (color & 0xFF);
        *pic24out++ = (color >>  8) & 0xFF;
        *pic24out++ = (color >> 16) & 0xFF;
    }
}

/*
==============
Img_UnPalettize16
==============
*/
void Img_UnPalettize16(int width, int height, const byte * restrict pic8in,
                       const u32 * restrict palette, byte * restrict pic16out)
{
    int i;
    u32 color;
    byte r, g, b, a;
    const int pixel_count = width * height;
    u16 * restrict dest = (u16 *)pic16out;

    for (i = 0; i < pixel_count; ++i)
    {
        color = palette[pic8in[i]];

        r = (color & 0xFF);
        g = (color >>  8) & 0xFF;
        b = (color >> 16) & 0xFF;
        a = (color >> 24) & 0xFF;

        *dest++ = RGBA16(r, g, b, a);
    }
}

#undef RGBA16

