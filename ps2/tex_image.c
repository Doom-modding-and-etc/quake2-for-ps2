
/* ================================================================================================
 * -*- C -*-
 * File: tex_image.c
 * Author: Guilherme R. Lampert
 * Created on: 18/10/15
 * Brief: Texture management and image loading for the PS2.
 *
 * This source code is released under the GNU GPL v2 license.
 * Check the accompanying LICENSE file for details.
 * ================================================================================================ */

#include "ref_ps2.h"
#include "mem_alloc.h"
#include "../common/q_files.h"

#include <draw.h>
#include <gs_psm.h>

//
// Built-in images found in src/ps2/builtin/
//
// These are common UI textures like the console
// chars and overlays that I've dumped as raw
// arrays of bytes from the originals found in
// pak0.pak. The ones with no transparency are
// stored as uint16s to save space, conchars.pcx
// is saved as an array of RGBA bytes.
//
// I've embedded these mostly to facilitate testing,
// since it makes the executable stand-alone and we
// can still draw the console nicely. There's an imgdump.c
// file that is the tool used to read the PCX images
// and dump the pixels as arrays of bytes.
//
// ps2_global_palette is also generated by it from colormap.pcx.
//

// conchars.pcx RGBA-32:
extern const int conchars_width;
extern const int conchars_height;
extern const byte conchars_data[];

// conback.pcx RGB-16:
extern const int conback_width;
extern const int conback_height;
extern const byte conback_data[];

// inventory.pcx RGB-16:
extern const int inventory_width;
extern const int inventory_height;
extern const byte inventory_data[];

// help.pcx RGB-16:
extern const int help_width;
extern const int help_height;
extern const byte help_data[];

// backtile.pcx RGB-16:
extern const int backtile_width;
extern const int backtile_height;
extern const byte backtile_data[];

// These are always available in main RAM, since the
// texture data comes directly from the above arrays.
ps2_teximage_t * ps2_builtin_tex_conchars  = NULL;
ps2_teximage_t * ps2_builtin_tex_conback   = NULL;
ps2_teximage_t * ps2_builtin_tex_inventory = NULL;
ps2_teximage_t * ps2_builtin_tex_help      = NULL;
ps2_teximage_t * ps2_builtin_tex_backtile  = NULL;
ps2_teximage_t * ps2_builtin_tex_debug     = NULL;

// Stats for debug printing:
int ps2_teximages_used         = 0;
int ps2_teximage_cache_hits    = 0;
int ps2_unused_teximages_freed = 0;
int ps2_teximages_failed       = 0;
int ps2_scrap_allocs           = 0;
int ps2_teximage_load_time     = 0;

// These allow skipping the load of a given texture type.
// When set, the returned texture will be the built-in debug texture.
static cvar_t * r_ps2_skip_skin_tex_load   = NULL;
static cvar_t * r_ps2_skip_sprite_tex_load = NULL;
static cvar_t * r_ps2_skip_wall_tex_load   = NULL;
static cvar_t * r_ps2_skip_sky_tex_load    = NULL;
static cvar_t * r_ps2_skip_pic_tex_load    = NULL;

//=============================================================================
//
// Texture image allocations and management:
//
//=============================================================================

// Pack an RGBA into a 16bits word. 1 bit alpha, A-B-G-R internal order.
#define RGBA16(r, g, b, a) \
    ((((a) & 0x1) << 15) | (((b) >> 3) << 10) | (((g) >> 3) << 5) | ((r) >> 3))

// Used for image name hashing.
extern u32 Sys_HashString(const char * str);

/*
==============
MakeCheckerPattern

Remarks: Local function.
Makes a checker pattern texture for ps2_builtin_tex_debug.
==============
*/
enum
{
    CHECKER_DIM     = 64,
    CHECKER_SQUARES = 4,
    CHECKER_SIZE    = CHECKER_DIM / CHECKER_SQUARES
};
static u16 * MakeCheckerPattern(void) // RGBA 16bits
{
    const u16 colors[] =
    {
        RGBA16(255, 100, 255, 255), // pink
        RGBA16(0, 0, 0, 255)        // black
    };
    static u16 buffer[CHECKER_DIM * CHECKER_DIM] PS2_ALIGN(16);

    int x, y, colorindex;
    for (y = 0; y < CHECKER_DIM; ++y)
    {
        for (x = 0; x < CHECKER_DIM; ++x)
        {
            colorindex = ((y / CHECKER_SIZE) + (x / CHECKER_SIZE)) % 2;
            buffer[x + (y * CHECKER_DIM)] = colors[colorindex];
        }
    }

    return buffer;
}

/*
==============
PS2_TexImageInit
==============
*/
void PS2_TexImageInit(void)
{
    if (ps2_teximages_used != 0)
    {
        Sys_Error("Invalid PS2_TexImageInit call!");
    }

    r_ps2_skip_skin_tex_load   = Cvar_Get("r_ps2_skip_skin_tex_load",   "1", 0);
    r_ps2_skip_sprite_tex_load = Cvar_Get("r_ps2_skip_sprite_tex_load", "1", 0);
    r_ps2_skip_wall_tex_load   = Cvar_Get("r_ps2_skip_wall_tex_load",   "1", 0);
    r_ps2_skip_sky_tex_load    = Cvar_Get("r_ps2_skip_sky_tex_load",    "1", 0);
    r_ps2_skip_pic_tex_load    = Cvar_Get("r_ps2_skip_pic_tex_load",    "0", 0);

    //
    // Create the built-in textures:
    //

    ps2_builtin_tex_debug = PS2_TexImageAlloc();
    PS2_TexImageSetup(ps2_builtin_tex_debug, "pics/debug.pcx", CHECKER_DIM, CHECKER_DIM,
                      TEXTURE_COMPONENTS_RGB, TEXTURE_FUNCTION_MODULATE, GS_PSM_16,
                      LOD_MAG_NEAREST, LOD_MIN_NEAREST, IT_BUILTIN, (byte *)MakeCheckerPattern());

    ps2_builtin_tex_inventory = PS2_TexImageAlloc();
    PS2_TexImageSetup(ps2_builtin_tex_inventory, "pics/inventory.pcx", inventory_width, inventory_height,
                      TEXTURE_COMPONENTS_RGB, TEXTURE_FUNCTION_MODULATE, GS_PSM_16,
                      LOD_MAG_NEAREST, LOD_MIN_NEAREST, IT_BUILTIN, (byte *)inventory_data);

    ps2_builtin_tex_help = PS2_TexImageAlloc();
    PS2_TexImageSetup(ps2_builtin_tex_help, "pics/help.pcx", help_width, help_height,
                      TEXTURE_COMPONENTS_RGB, TEXTURE_FUNCTION_MODULATE, GS_PSM_16,
                      LOD_MAG_NEAREST, LOD_MIN_NEAREST, IT_BUILTIN, (byte *)help_data);

    ps2_builtin_tex_conback = PS2_TexImageAlloc();
    PS2_TexImageSetup(ps2_builtin_tex_conback, "pics/conback.pcx", conback_width, conback_height,
                      TEXTURE_COMPONENTS_RGB, TEXTURE_FUNCTION_MODULATE, GS_PSM_16,
                      LOD_MAG_NEAREST, LOD_MIN_NEAREST, IT_BUILTIN, (byte *)conback_data);

    ps2_builtin_tex_backtile = PS2_TexImageAlloc();
    PS2_TexImageSetup(ps2_builtin_tex_backtile, "pics/backtile.pcx", backtile_width,backtile_height,
                      TEXTURE_COMPONENTS_RGB, TEXTURE_FUNCTION_MODULATE, GS_PSM_16,
                      LOD_MAG_NEAREST, LOD_MIN_NEAREST, IT_BUILTIN, (byte *)backtile_data);

    ps2_builtin_tex_conchars = PS2_TexImageAlloc();
    PS2_TexImageSetup(ps2_builtin_tex_conchars, "pics/conchars.pcx", conchars_width, conchars_height,
                      TEXTURE_COMPONENTS_RGBA, TEXTURE_FUNCTION_MODULATE, GS_PSM_32,
                      LOD_MAG_NEAREST, LOD_MIN_NEAREST, IT_BUILTIN, (byte *)conchars_data);
}

/*
==============
PS2_TexImageShutdown
==============
*/
void PS2_TexImageShutdown(void)
{
    // Free all non-null, non-built-in images:
    int i;
    ps2_teximage_t * teximage_iter = ps2ref.teximages;
    for (i = 0; i < MAX_TEXIMAGES; ++i, ++teximage_iter)
    {
        if (teximage_iter->type == IT_NULL || teximage_iter->type == IT_BUILTIN)
        {
            continue;
        }
        PS2_TexImageFree(teximage_iter);
    }
    ps2_teximages_used = 0;
}

/*
==============
PS2_TexImageAlloc
==============
*/
ps2_teximage_t * PS2_TexImageAlloc(void)
{
    if (ps2_teximages_used == MAX_TEXIMAGES)
    {
        Sys_Error("Out of tex image objects!!!");
    }

    //
    // Find a free slot in the image pool:
    //
    int i;
    ps2_teximage_t * teximage_iter = ps2ref.teximages;
    for (i = 0; i < MAX_TEXIMAGES; ++i, ++teximage_iter)
    {
        if (teximage_iter->type == IT_NULL)
        {
            ++ps2_teximages_used;
            return teximage_iter;
        }
    }

    Sys_Error("Out of tex image objects! Can't find a free slot!");
    return NULL;
}

/*
==============
PS2_TexImageFree
==============
*/
void PS2_TexImageFree(ps2_teximage_t * teximage)
{
    if (teximage == NULL)
    {
        return;
    }

    // Built-ins will always be referencing static program data.
    if (teximage->pic != NULL && teximage->type != IT_BUILTIN)
    {
        int size_bytes;
        switch (teximage->texbuf.psm)
        {
        case GS_PSM_32 :
            size_bytes = (teximage->width * teximage->height * 4);
            break;
        case GS_PSM_16 :
            size_bytes = (teximage->width * teximage->height * 2);
            break;
        default : // Assume 8bits palettized.
            size_bytes = (teximage->width * teximage->height * 1);
            break;
        } // switch (teximage->texbuf.psm)

        PS2_MemFree(teximage->pic, size_bytes, MEMTAG_TEXIMAGE);
        PS2_MemClearObj(teximage);
        --ps2_teximages_used;
    }
}

/*
==============
PS2_TexImageFreeUnused
==============
*/
void PS2_TexImageFreeUnused(void)
{
    int i;
    ps2_teximage_t * teximage_iter = ps2ref.teximages;
    for (i = 0; i < MAX_TEXIMAGES; ++i, ++teximage_iter)
    {
        if (teximage_iter->type == IT_NULL || teximage_iter->type == IT_BUILTIN)
        {
            continue;
        }
        if (teximage_iter->registration_sequence != ps2ref.registration_sequence)
        {
            PS2_TexImageFree(teximage_iter);
            ++ps2_unused_teximages_freed;
        }
    }
}

/*
==============
IsPowerOfTwo

Remarks: Local function.
==============
*/
static inline int IsPowerOfTwo(int x)
{
    return (x > 0) && (x & (x - 1)) == 0;
}

/*
==============
RoundToPowerOfTwo

Remarks: Local function.
==============
*/
static inline int RoundToPowerOfTwo(int x)
{
    if (IsPowerOfTwo(x))
    {
        return x;
    }

    // Round nearest:
    int k, p2;
    for (k = sizeof(int) * 8 - 1; ((1 << k) & x) == 0; --k)
    {
    }

    if (((1 << (k - 1)) & x) == 0)
    {
        p2 = 1 << k;
    }
    else
    {
        p2 = 1 << (k + 1);
    }

    return (p2 < MAX_TEXIMAGE_SIZE) ? p2 : MAX_TEXIMAGE_SIZE;

    // Round down:
    /*
    int p2;
    for (p2 = 1; (p2 * 2) <= x; p2 <<= 1) { }
    return (p2 < MAX_TEXIMAGE_SIZE) ? p2 : MAX_TEXIMAGE_SIZE;
    */
}

/*
==============
Common8BitTexSetup

Remarks: Local function.
==============
*/
static ps2_teximage_t * Common8BitTexSetup(const byte * pic8, int width, int height, const char * name, int flags)
{
    byte * expanded_pic;
    byte * scaled_pic;
    ps2_teximage_t * teximage;

    int psm        = GS_PSM_16;
    int format     = TEXTURE_COMPONENTS_RGB;
    int mag_filter = LOD_MAG_LINEAR;
    int min_filter = LOD_MIN_LINEAR;

    // Clamp down to our size limit or round to PoT. This will also force RGBA32.
    if (width  > MAX_TEXIMAGE_SIZE ||
        height > MAX_TEXIMAGE_SIZE ||
        !IsPowerOfTwo(width)       ||
        !IsPowerOfTwo(height))
    {
        psm    = GS_PSM_32;
        format = TEXTURE_COMPONENTS_RGBA;

        const int scaled_width  = (width  >= MAX_TEXIMAGE_SIZE) ? MAX_TEXIMAGE_SIZE : RoundToPowerOfTwo(width);
        const int scaled_height = (height >= MAX_TEXIMAGE_SIZE) ? MAX_TEXIMAGE_SIZE : RoundToPowerOfTwo(height);

        expanded_pic = PS2_MemAlloc(width * height * 4, MEMTAG_TEXIMAGE);
        scaled_pic   = PS2_MemAlloc(scaled_width * scaled_height * 4, MEMTAG_TEXIMAGE);

        Img_UnPalettize32(width, height, pic8, ps2_global_palette, expanded_pic);
        Img_Resample32((u32 *)expanded_pic, width, height, (u32 *)scaled_pic, scaled_width, scaled_height);

        PS2_MemFree(expanded_pic, (width * height * 4), MEMTAG_TEXIMAGE);

        width  = scaled_width;
        height = scaled_height;
        expanded_pic = scaled_pic;
    }
    else
    {
        int i;
        const int pixel_count = width * height;

        // Check if the image has transparency, if so, we need 32bit color.
        for (i = 0; i < pixel_count; ++i)
        {
            if (pic8[i] == 255) // Transparent color
            {
                // Need 32bit RGBA.
                psm    = GS_PSM_32;
                format = TEXTURE_COMPONENTS_RGBA;
                break;
            }
        }

        if (format == TEXTURE_COMPONENTS_RGBA)
        {
            expanded_pic = PS2_MemAlloc(width * height * 4, MEMTAG_TEXIMAGE);
            Img_UnPalettize32(width, height, pic8, ps2_global_palette, expanded_pic);
        }
        else // Use more compact 16bit RGB color.
        {
            expanded_pic = PS2_MemAlloc(width * height * 2, MEMTAG_TEXIMAGE);
            Img_UnPalettize16(width, height, pic8, ps2_global_palette, expanded_pic);
        }
    }

    // IT_BUILTIN is only used internally as a type.
    // Can't be present if loaded from file, so mask it off.
    const int img_type = flags & (~IT_BUILTIN);

    // Sprites can do with a cheaper filtering.
    // Pics (2D UI elements and such) actually look better with nearest sampling.
    if (img_type & (IT_PIC | IT_SPRITE))
    {
        mag_filter = LOD_MAG_NEAREST;
        min_filter = LOD_MIN_NEAREST;
    }

    // Finally, allocate and set up the image handle:
    teximage = PS2_TexImageAlloc();
    PS2_TexImageSetup(teximage, name, width, height, format, TEXTURE_FUNCTION_MODULATE,
                      psm, mag_filter, min_filter, (ps2_imagetype_t)img_type, expanded_pic);

    return teximage;
}

/*
==============
LoadPcxImpl

Remarks: Local function.
==============
*/
static ps2_teximage_t * LoadPcxImpl(const char * name, int flags)
{
    int width;
    int height;
    byte * pic8;
    ps2_teximage_t * teximage = NULL;

    if (!PCX_LoadFromFile(name, &pic8, NULL, &width, &height))
    {
        Com_DPrintf("WARNING: Can't load PCX pic for '%s'\n", name);
        return NULL;
    }

    // Try placing small images in the scrap atlas:
    if ((flags & IT_PIC) && width <= 64 && height <= 166)
    {
        // Notice that we allow some pretty tall images (h <= 166).
        // That's the size of 'm_main_plaque', the Quake2 logo in
        // the main menu. This image was impossible to resize in
        // a descent way on allocation, so I've change the atlas
        // allocation criteria here to allow it's height, so it
        // will not be a standalone image and won't require a resize.
        teximage = Img_ScrapAlloc(pic8, width, height, name);
    }

    // Atlas full or image too big, create a standalone texture:
    if (teximage == NULL)
    {
        teximage = Common8BitTexSetup(pic8, width, height, name, flags);
    }

    // The palettized image is no longer needed.
    PS2_MemFree(pic8, width * height, MEMTAG_TEXIMAGE);

    teximage->registration_sequence = ps2ref.registration_sequence;
    return teximage;
}

/*
==============
LoadWalImpl

Remarks: Local function.
==============
*/
static ps2_teximage_t * LoadWalImpl(const char * name, int flags)
{
    ps2_teximage_t * teximage;
    const miptex_t * wall;
    const byte     * pic8;
    int width;
    int height;
    int offset;
    int data_len;

    data_len = FS_LoadFile(name, (void **)&wall);
    if (wall == NULL || data_len <= 0)
    {
        Com_DPrintf("WARNING: Can't load WAL texture for '%s'\n", name);
        return NULL;
    }

    width  = LittleLong(wall->width);
    height = LittleLong(wall->height);
    offset = LittleLong(wall->offsets[0]);
    pic8   = (const byte *)wall + offset;

    teximage = Common8BitTexSetup(pic8, width, height, name, flags | IT_WALL);

    FS_FreeFile((void *)wall);

    teximage->registration_sequence = ps2ref.registration_sequence;
    return teximage;
}

/*
==============
LoadTgaImpl

Remarks: Local function.
==============
*/
static ps2_teximage_t * LoadTgaImpl(const char * name, int flags)
{
    byte * pic32;
    int width;
    int height;

    if (!TGA_LoadFromFile(name, &pic32, &width, &height))
    {
        Com_DPrintf("WARNING: Can't load TGA texture for '%s'\n", name);
        return NULL;
    }

    // IT_BUILTIN is only used internally as a type.
    // Can't be present if loaded from file, so mask it off.
    const int img_type = flags & (~IT_BUILTIN);

    // TGA defaults:
    const int psm        = GS_PSM_32;
    const int format     = TEXTURE_COMPONENTS_RGBA;
    const int mag_filter = LOD_MAG_LINEAR;
    const int min_filter = LOD_MIN_LINEAR;

    //
    // TGAs are always expanded to RGBA, so no extra conversion is needed.
    //
    // NOTE: We assume TGAs will always be under the maximum texture size (256^2).
    // This should be true, since TGAs are only used for the skyboxes in Quake2.
    // If that assumption is violated, you'll get a Sys_Error in the image setup.
    //
    ps2_teximage_t * teximage = PS2_TexImageAlloc();
    PS2_TexImageSetup(teximage, name, width, height, format, TEXTURE_FUNCTION_MODULATE,
                      psm, mag_filter, min_filter, (ps2_imagetype_t)img_type, pic32);

    teximage->registration_sequence = ps2ref.registration_sequence;
    return teximage;
}

/*
==============
FindImageImpl

Remarks: Local function.
==============
*/
static ps2_teximage_t * FindImageImpl(const char * name, int flags)
{
    if (name == NULL || *name == '\0')
    {
        Com_DPrintf("FindImage: Null/empty image name!\n");
        ++ps2_teximages_failed;
        return NULL;
    }

    const u32 name_len = strlen(name);
    if (name_len < 5 || name_len >= MAX_QPATH)
    {
        Com_DPrintf("FindImage: Bad image name length: '%s'\n", name);
        ++ps2_teximages_failed;
        return NULL;
    }

    // Compare by hash code, much cheaper.
    const u32 name_hash = Sys_HashString(name);

    //
    // First, lookup our cache:
    //
    int i;
    ps2_teximage_t * teximage_iter = ps2ref.teximages;
    for (i = 0; i < MAX_TEXIMAGES; ++i, ++teximage_iter)
    {
        if (teximage_iter->type == IT_NULL)
        {
            continue;
        }
        if ((name_hash == teximage_iter->hash) && (flags & teximage_iter->type))
        {
            if (ps2ref.registration_started)
            {
                ++ps2_teximage_cache_hits;
            }

            teximage_iter->registration_sequence = ps2ref.registration_sequence;
            return teximage_iter;
        }
    }

    //
    // Load from file for the first time:
    //
    ps2_teximage_t * new_image;
    const int start_time = Sys_Milliseconds();
    {
        if (strcmp(name + name_len - 4, ".pcx") == 0)
        {
            new_image = LoadPcxImpl(name, flags);
        }
        else if (strcmp(name + name_len - 4, ".wal") == 0)
        {
            new_image = LoadWalImpl(name, flags);
        }
        else if (strcmp(name + name_len - 4, ".tga") == 0)
        {
            new_image = LoadTgaImpl(name, flags);
        }
        else
        {
            Com_DPrintf("WARNING: Unable to find image '%s'\n", name);
            ++ps2_teximages_failed;
            new_image = NULL;
        }
    }
    const int end_time = Sys_Milliseconds();
    ps2_teximage_load_time += end_time - start_time;
    return new_image;
}

/*
==============
PS2_TexImageFindOrLoad
==============
*/
ps2_teximage_t * PS2_TexImageFindOrLoad(const char * name, int flags)
{
    ps2_teximage_t * teximage = NULL;
    char fullname[MAX_QPATH];

    if (flags & (IT_PIC | IT_BUILTIN))
    {
        if (r_ps2_skip_pic_tex_load->value)
        {
            teximage = ps2_builtin_tex_debug;
        }
        else
        {
            // This is the same logic used by ref_gl.
            // If the name doesn't start with a path separator, its just the base
            // filename, like "conchars", otherwise the full file path is specified in 'name'.
            if (name[0] != '/' && name[0] != '\\')
            {
                Com_sprintf(fullname, sizeof(fullname), "pics/%s.pcx", name);
                teximage = FindImageImpl(fullname, flags);
            }
            else
            {
                teximage = FindImageImpl(name + 1, flags);
            }
        }
    }
    else // Skins, walls, etc:
    {
        // Might want to skip a certain class of images...
        if ((flags & IT_SKIN) && r_ps2_skip_skin_tex_load->value)
        {
            teximage = ps2_builtin_tex_debug;
        }
        else if ((flags & IT_SPRITE) && r_ps2_skip_sprite_tex_load->value)
        {
            teximage = ps2_builtin_tex_debug;
        }
        else if ((flags & IT_WALL) && r_ps2_skip_wall_tex_load->value)
        {
            teximage = ps2_builtin_tex_debug;
        }
        else if ((flags & IT_SKY) && r_ps2_skip_sky_tex_load->value)
        {
            teximage = ps2_builtin_tex_debug;
        }
        else // Load normally:
        {
            teximage = FindImageImpl(name, flags);
        }
    }

    return teximage;
}

/*
==============
PS2_TexImageSetup
==============
*/
void PS2_TexImageSetup(ps2_teximage_t * teximage, const char * name, int w, int h, int components,
                       int func, int psm, int mag_filter, int min_filter, ps2_imagetype_t type, byte * pic)
{
    if (w <= 0 || w > MAX_TEXIMAGE_SIZE)
    {
        Sys_Error("Bad texture width (%d) for %s!", w, name);
    }
    if (h <= 0 || h > MAX_TEXIMAGE_SIZE)
    {
        Sys_Error("Bad texture height (%d) for %s!", h, name);
    }

    // All textures must share the same VRam space.
    // What this means is that we only have enough VRam
    // left for a single texture at a time, so every texture
    // must be copied to VRam on-the-fly, prior to any use.
    teximage->texbuf.address         = ps2ref.vram_texture_start;
    teximage->pic                    = pic;
    teximage->width                  = w;
    teximage->height                 = h;
    teximage->mag_filter             = mag_filter;
    teximage->min_filter             = min_filter;
    teximage->type                   = type;
    teximage->texbuf.psm             = psm;
    teximage->texbuf.width           = w;
    teximage->texbuf.info.width      = draw_log2(w);
    teximage->texbuf.info.height     = draw_log2(h);
    teximage->texbuf.info.components = components;
    teximage->texbuf.info.function   = func;
    teximage->registration_sequence  = 0;
    teximage->texture_chain          = NULL;
    // These are only used by the scrap atlas:
    teximage->u0 = teximage->u1      = 0;
    teximage->v0 = teximage->v1      = 0;
    // Finally, copy and hash the name string:
    strncpy(teximage->name, name, MAX_QPATH);
    teximage->hash = Sys_HashString(name);
}

/*
==============
Img_Resample32

Adapted from ref_gl GL_ResampleTexture.
NOTE: Input and out images must be different buffers!
==============
*/
void Img_Resample32(const u32 * restrict in_img, int in_width, int in_height,
                    u32 * restrict out_img, int out_width, int out_height)
{
    int i, j;
    u32 frac;
    const u32  * inrow;
    const u32  * inrow2;
    const byte * pix1;
    const byte * pix2;
    const byte * pix3;
    const byte * pix4;

    // 512 is the max output w|h. We only really use up to 256 (MAX_TEXIMAGE_SIZE).
    u32 p1[512] PS2_ALIGN(16);
    u32 p2[512] PS2_ALIGN(16);

    const u32 fracstep = in_width * 0x10000 / out_width;

    frac = fracstep >> 2;
    for (i = 0; i < out_width; i++)
    {
        p1[i] = 4 * (frac >> 16);
        frac += fracstep;
    }

    frac = 3 * (fracstep >> 2);
    for (i = 0; i < out_width; i++)
    {
        p2[i] = 4 * (frac >> 16);
        frac += fracstep;
    }

    // This is a box filter, I think...
    for (i = 0; i < out_height; i++, out_img += out_width)
    {
        inrow  = in_img + in_width * (int)((i + 0.25) * in_height / out_height);
        inrow2 = in_img + in_width * (int)((i + 0.75) * in_height / out_height);
        frac = fracstep >> 1;

        for (j = 0; j < out_width; j++)
        {
            pix1 = (const byte *)inrow  + p1[j];
            pix2 = (const byte *)inrow  + p2[j];
            pix3 = (const byte *)inrow2 + p1[j];
            pix4 = (const byte *)inrow2 + p2[j];

            ((byte *)(out_img + j))[0] = (pix1[0] + pix2[0] + pix3[0] + pix4[0]) >> 2;
            ((byte *)(out_img + j))[1] = (pix1[1] + pix2[1] + pix3[1] + pix4[1]) >> 2;
            ((byte *)(out_img + j))[2] = (pix1[2] + pix2[2] + pix3[2] + pix4[2]) >> 2;
            ((byte *)(out_img + j))[3] = (pix1[3] + pix2[3] + pix3[3] + pix4[3]) >> 2;
        }
    }
}

/*
==============
Img_ScrapAlloc

Scrap allocation - AKA texture atlas.
Useful to group small textures into a larger one,
reducing the number of texture switches when rendering.
==============
*/
ps2_teximage_t * Img_ScrapAlloc(const byte * pic8in, int w, int h, const char * pic_name)
{
    static int scrap_allocated[MAX_TEXIMAGE_SIZE] PS2_ALIGN(16);
    static u32 scrap_pixels[MAX_TEXIMAGE_SIZE * MAX_TEXIMAGE_SIZE] PS2_ALIGN(16);

    int i, j, k;
    int sx, sy;
    int best, best2;
    ps2_teximage_t * scrap_teximage;
    u32 temp_pic32[MAX_TEXIMAGE_SIZE * MAX_TEXIMAGE_SIZE] PS2_ALIGN(16);

    sx = sy = 0;
    best = MAX_TEXIMAGE_SIZE;

    // Try to find a good fit in the atlas:
    for (i = 0; i < MAX_TEXIMAGE_SIZE - w; ++i)
    {
        best2 = 0;
        for (j = 0; j < w; ++j)
        {
            if (scrap_allocated[i + j] >= best)
            {
                break;
            }
            if (scrap_allocated[i + j] > best2)
            {
                best2 = scrap_allocated[i + j];
            }
        }

        if (j == w) // This is a valid spot
        {
            sx = i;
            sy = best = best2;
        }
    }

    // No more room.
    if ((best + h) > MAX_TEXIMAGE_SIZE)
    {
        return NULL;
    }

    // Managed to allocate, update the scrap:
    for (i = 0; i < w; ++i)
    {
        scrap_allocated[sx + i] = best + h;
    }

    // Expand the pic to RGBA:
    Img_UnPalettize32(w, h, pic8in, ps2_global_palette, (byte *)temp_pic32);

    // Copy the texels into the scrap block:
    k = 0;
    for (i = 0; i < h; ++i)
    {
        for (j = 0; j < w; ++j, ++k)
        {
            scrap_pixels[(sy + i) * MAX_TEXIMAGE_SIZE + sx + j] = temp_pic32[k];
        }
    }

    scrap_teximage = PS2_TexImageAlloc();
    PS2_TexImageSetup(scrap_teximage, pic_name, w, h, TEXTURE_COMPONENTS_RGBA,
                      TEXTURE_FUNCTION_MODULATE, GS_PSM_32, LOD_MAG_NEAREST,
                      LOD_MIN_NEAREST, IT_BUILTIN, (byte *)scrap_pixels);

    scrap_teximage->u0 = sx;
    scrap_teximage->v0 = sy;
    scrap_teximage->u1 = sx + w;
    scrap_teximage->v1 = sy + h;

    ps2_scrap_allocs++;
    return scrap_teximage;
}

//=============================================================================
//
// PCX image loading helpers:
//
//=============================================================================

/*
==============
PCX_LoadFromMemory

'pic' and 'palette' can be null if you want to ignore one or the other.
If 'palette' is not null, it must point to an array of 256 32bit integers.
Mostly adapted from ref_gl/gl_image.c
==============
*/
qboolean PCX_LoadFromMemory(const char * filename, const byte * data, int data_len,
                            byte ** pic, u32 * palette, int * width, int * height)
{
    enum
    {
        PCX_PAL_SIZE_BYTES = 768
    };

    byte * pix;
    int x, y;
    int data_byte;
    int run_length;

    // Endian swap the header fields larger than a byte:
    const pcx_t * pcx  = (const pcx_t *)data;
    int manufacturer   = pcx->manufacturer;
    int version        = pcx->version;
    int encoding       = pcx->encoding;
    int bits_per_pixel = pcx->bits_per_pixel;
    int xmax           = LittleShort(pcx->xmax);
    int ymax           = LittleShort(pcx->ymax);

    // Validate the image:
    if (manufacturer != 0x0A || version != 5 || encoding != 1 ||
        bits_per_pixel != 8  || xmax >= 640  || ymax >= 480)
    {
        Com_DPrintf("Bad PCX file %s. Invalid header value(s)!\n", filename);
        return false;
    }

    // Get the palette:
    if (palette != NULL)
    {
        byte temp_pal[PCX_PAL_SIZE_BYTES] PS2_ALIGN(16);
        memcpy(temp_pal, (const byte *)pcx + data_len - PCX_PAL_SIZE_BYTES, PCX_PAL_SIZE_BYTES);

        // Adjust the palette and fix byte order if needed:
        u32 c;
        int i, r, g, b;
        for (i = 0; i < 256; ++i)
        {
            r = temp_pal[(i * 3) + 0];
            g = temp_pal[(i * 3) + 1];
            b = temp_pal[(i * 3) + 2];
            c = (255 << 24) + (r << 0) + (g << 8) + (b << 16);
            palette[i] = LittleLong(c);
        }
        palette[255] &= LittleLong(0xFFFFFF); // 255 is transparent
    }

    if (width != NULL)
    {
        *width = xmax + 1;
    }
    if (height != NULL)
    {
        *height = ymax + 1;
    }

    if (pic == NULL)
    {
        // Caller just wanted the palette.
        return true;
    }

    // Now alloc and read in the pixel data:
    pix = PS2_MemAlloc((xmax + 1) * (ymax + 1), MEMTAG_TEXIMAGE);
    *pic = pix;

    // Skip the header:
    data = &pcx->data;

    // Decode the RLE packets:
    for (y = 0; y <= ymax; y++, pix += xmax + 1)
    {
        for (x = 0; x <= xmax;)
        {
            data_byte = *data++;
            if ((data_byte & 0xC0) == 0xC0)
            {
                run_length = data_byte & 0x3F;
                data_byte  = *data++;
            }
            else
            {
                run_length = 1;
            }

            while (run_length-- > 0)
            {
                pix[x++] = data_byte;
            }
        }
    }

    if ((data - (const byte *)pcx) > data_len)
    {
        Com_DPrintf("PCX image %s was malformed!\n", filename);

        int size_bytes = (xmax + 1) * (ymax + 1);
        PS2_MemFree(*pic, size_bytes, MEMTAG_TEXIMAGE);
        *pic = NULL;

        return false;
    }

    return true;
}

/*
==============
PCX_LoadFromFile

Mostly adapted from ref_gl/gl_image.c
==============
*/
qboolean PCX_LoadFromFile(const char * filename, byte ** pic,
                          u32 * palette, int * width, int * height)
{
    qboolean result;
    int data_len;
    byte * data;

    data_len = FS_LoadFile(filename, (void **)&data);
    if (data == NULL || data_len <= 0)
    {
        Com_DPrintf("Bad PCX file '%s'\n", filename);
        return false;
    }

    result = PCX_LoadFromMemory(filename, data, data_len, pic, palette, width, height);
    FS_FreeFile(data);

    return result;
}

//=============================================================================
//
// TGA image loading helpers:
//
//=============================================================================

typedef struct
{
    byte id_length;
    byte colormap_type;
    byte image_type;
    u16  colormap_index;
    u16  colormap_length;
    byte colormap_size;
    u16  x_origin;
    u16  y_origin;
    u16  width;
    u16  height;
    byte pixel_size;
    byte attributes;
} tga_header_t;

/*
==============
TGA_LoadFromFile

Mostly adapted from LoadTGA, ref_gl/gl_image.c
NOTE: Output image is always RGBA 32bits.
==============
*/
qboolean TGA_LoadFromFile(const char * filename, byte ** pic, int * width, int * height)
{
    tga_header_t targa_header;

    int data_len;
    int pixel_count;
    int column, columns;
    int row, rows;

    byte * pixbuf;
    byte * buf_p;
    byte * buffer;
    byte * targa_rgba;
    byte tmp[2];

    *pic = NULL;

    data_len = FS_LoadFile(filename, (void **)&buffer);
    if (buffer == NULL || data_len <= 0)
    {
        Com_DPrintf("Bad TGA file '%s'\n", filename);
        return false;
    }

    buf_p = buffer;
    targa_header.id_length     = *buf_p++;
    targa_header.colormap_type = *buf_p++;
    targa_header.image_type    = *buf_p++;

    tmp[0] = buf_p[0];
    tmp[1] = buf_p[1];
    targa_header.colormap_index = LittleShort(*((short *)tmp));
    buf_p += 2;

    tmp[0] = buf_p[0];
    tmp[1] = buf_p[1];
    targa_header.colormap_length = LittleShort(*((short *)tmp));
    buf_p += 2;

    targa_header.colormap_size = *buf_p++;

    targa_header.x_origin = LittleShort(*((short *)buf_p));
    buf_p += 2;

    targa_header.y_origin = LittleShort(*((short *)buf_p));
    buf_p += 2;

    targa_header.width = LittleShort(*((short *)buf_p));
    buf_p += 2;

    targa_header.height = LittleShort(*((short *)buf_p));
    buf_p += 2;

    targa_header.pixel_size = *buf_p++;
    targa_header.attributes = *buf_p++;

    if (targa_header.image_type != 2 && targa_header.image_type != 10)
    {
        Com_DPrintf("TGA_LoadFromFile: Only type 2 and 10 targa RGB images supported! %s\n", filename);
        FS_FreeFile(buffer);
        return false;
    }

    if (targa_header.colormap_type != 0 || (targa_header.pixel_size != 32 && targa_header.pixel_size != 24))
    {
        Com_DPrintf("TGA_LoadFromFile: Only 32 or 24 bit images supported (no colormaps)! %s\n", filename);
        FS_FreeFile(buffer);
        return false;
    }

    columns     = targa_header.width;
    rows        = targa_header.height;
    pixel_count = columns * rows;

    if (width != NULL)
    {
        *width = columns;
    }
    if (height != NULL)
    {
        *height = rows;
    }

    targa_rgba = PS2_MemAlloc(pixel_count * 4, MEMTAG_TEXIMAGE);
    *pic = targa_rgba;

    if (targa_header.id_length != 0)
    {
        buf_p += targa_header.id_length; // skip TARGA image comment
    }

    if (targa_header.image_type == 2) // Uncompressed, RGB images
    {
        for (row = rows - 1; row >= 0; --row)
        {
            pixbuf = targa_rgba + row * columns * 4;
            for (column = 0; column < columns; ++column)
            {
                byte red, green, blue, alpha;

                switch (targa_header.pixel_size)
                {
                case 24 :
                    blue      = *buf_p++;
                    green     = *buf_p++;
                    red       = *buf_p++;
                    *pixbuf++ = red;
                    *pixbuf++ = green;
                    *pixbuf++ = blue;
                    *pixbuf++ = 255;
                    break;

                case 32 :
                    blue      = *buf_p++;
                    green     = *buf_p++;
                    red       = *buf_p++;
                    alpha     = *buf_p++;
                    *pixbuf++ = red;
                    *pixbuf++ = green;
                    *pixbuf++ = blue;
                    *pixbuf++ = alpha;
                    break;
                } // switch
            }
        }
    }
    else if (targa_header.image_type == 10) // Run-length encoded RGB images
    {
        byte red, green, blue, alpha;
        byte packetHeader, packetSize, j;

        for (row = rows - 1; row >= 0; --row)
        {
            pixbuf = targa_rgba + row * columns * 4;
            for (column = 0; column < columns;)
            {
                packetHeader = *buf_p++;
                packetSize = 1 + (packetHeader & 0x7F);

                if (packetHeader & 0x80) // Run-length packet
                {
                    switch (targa_header.pixel_size)
                    {
                    case 24 :
                        blue  = *buf_p++;
                        green = *buf_p++;
                        red   = *buf_p++;
                        alpha = 255;
                        break;

                    case 32 :
                        blue  = *buf_p++;
                        green = *buf_p++;
                        red   = *buf_p++;
                        alpha = *buf_p++;
                        break;
                    } // switch

                    for (j = 0; j < packetSize; ++j)
                    {
                        *pixbuf++ = red;
                        *pixbuf++ = green;
                        *pixbuf++ = blue;
                        *pixbuf++ = alpha;

                        ++column;
                        if (column == columns) // run spans across rows
                        {
                            column = 0;
                            if (row > 0)
                            {
                                --row;
                            }
                            else
                            {
                                goto BREAKOUT;
                            }
                            pixbuf = targa_rgba + row * columns * 4;
                        }
                    }
                }
                else // Non run-length packet
                {
                    for (j = 0; j < packetSize; ++j)
                    {
                        switch (targa_header.pixel_size)
                        {
                        case 24 :
                            blue      = *buf_p++;
                            green     = *buf_p++;
                            red       = *buf_p++;
                            *pixbuf++ = red;
                            *pixbuf++ = green;
                            *pixbuf++ = blue;
                            *pixbuf++ = 255;
                            break;

                        case 32 :
                            blue      = *buf_p++;
                            green     = *buf_p++;
                            red       = *buf_p++;
                            alpha     = *buf_p++;
                            *pixbuf++ = red;
                            *pixbuf++ = green;
                            *pixbuf++ = blue;
                            *pixbuf++ = alpha;
                            break;
                        } // switch

                        ++column;
                        if (column == columns) // pixel packet run spans across rows
                        {
                            column = 0;
                            if (row > 0)
                            {
                                --row;
                            }
                            else
                            {
                                goto BREAKOUT;
                            }
                            pixbuf = targa_rgba + row * columns * 4;
                        }
                    }
                }
            }
        BREAKOUT:
            ;
        }
    }

    FS_FreeFile(buffer);
    return true;
}

//=============================================================================
//
// Palettized image expansion:
//
//=============================================================================

/*
==============
Img_UnPalettize32

Transparency algorithm adapted from GL_Upload8 in ref_gl/gl_image.c
==============
*/
void Img_UnPalettize32(int width, int height, const byte * restrict pic8in,
                       const u32 * restrict palette, byte * restrict pic32out)
{
    int i, p;
    const int pixel_count = width * height;
    u32 * restrict rgba = (u32 *)pic32out;

    for (i = 0; i < pixel_count; ++i)
    {
        p = pic8in[i];
        rgba[i] = palette[p];

        if (p == 255)
        {
            // Transparent, so scan around for another
            // color to avoid alpha fringes
            if (i > width && pic8in[i - width] != 255)
            {
                p = pic8in[i - width];
            }
            else if (i < pixel_count - width && pic8in[i + width] != 255)
            {
                p = pic8in[i + width];
            }
            else if (i > 0 && pic8in[i - 1] != 255)
            {
                p = pic8in[i - 1];
            }
            else if (i < pixel_count - 1 && pic8in[i + 1] != 255)
            {
                p = pic8in[i + 1];
            }
            else
            {
                p = 0;
            }

            // Copy RGB components:
            ((byte *)&rgba[i])[0] = ((const byte *)&palette[p])[0];
            ((byte *)&rgba[i])[1] = ((const byte *)&palette[p])[1];
            ((byte *)&rgba[i])[2] = ((const byte *)&palette[p])[2];
        }
    }
}

/*
==============
Img_UnPalettize24
==============
*/
void Img_UnPalettize24(int width, int height, const byte * restrict pic8in,
                       const u32 * restrict palette, byte * restrict pic24out)
{
    int i;
    u32 color;
    const int pixel_count = width * height;

    for (i = 0; i < pixel_count; ++i)
    {
        color = palette[pic8in[i]];
        *pic24out++ = (color & 0xFF);
        *pic24out++ = (color >>  8) & 0xFF;
        *pic24out++ = (color >> 16) & 0xFF;
    }
}

/*
==============
Img_UnPalettize16
==============
*/
void Img_UnPalettize16(int width, int height, const byte * restrict pic8in,
                       const u32 * restrict palette, byte * restrict pic16out)
{
    int i;
    u32 color;
    byte r, g, b, a;
    const int pixel_count = width * height;
    u16 * restrict dest = (u16 *)pic16out;

    for (i = 0; i < pixel_count; ++i)
    {
        color = palette[pic8in[i]];

        r = (color & 0xFF);
        g = (color >>  8) & 0xFF;
        b = (color >> 16) & 0xFF;
        a = (color >> 24) & 0xFF;

        *dest++ = RGBA16(r, g, b, a);
    }
}

#undef RGBA16

